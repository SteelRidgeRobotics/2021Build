// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Subsystems/Vision.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "Commands/LimelightOff.h"

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Vision::Vision() : frc::Subsystem("Vision") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

table = nt::NetworkTableInstance::GetDefault().GetTable("limelight");

}

void Vision::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        SetDefaultCommand(new LimelightOff());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void Vision::Periodic() {
    // Put code here to be run every loop
double tx = table->GetNumber("tx",0.0);
double ty = table->GetNumber("ty",0.0);
double ta = table->GetNumber("ta",0.0);
double ts = table->GetNumber("ts",0.0);
double tv = table->GetNumber("tv", 0.0);
}

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


// Put methods for controlling this subsystem
// here. Call these from Commands.

bool Vision::getTv()

{
    double tv = table->GetNumber("tv", 0.0); 

    if (tv != 0.0)
    {
        return true;
    }

    else
    {
        return false;
    }
}

double Vision::getTx()
{
    double tx = table->GetNumber("tx", 0.0);

    return tx;
}

double Vision::getTy()
{
    double ty = table->GetNumber("ty", 0.0);

    return ty;
}

double Vision::getTa()
{
    double ta = table->GetNumber("ta", 0.0);

    return ta;
}

double Vision::getTs()
{
    double ts = table->GetNumber("ts", 0.0);

    return ts;
}

double Vision::getDistance() //d = (h2(height of obj)-h1(height of camera)) / tan(a1(ang above)+a2(ang below to ground))

{

double h1 = CAMERAHEIGHT;
double h2 = TARGETHEIGHT;
double hDif = h2 - h1;
double a1 = CAMERAANGOFFSET;
double a2 = getTy();
double aSum = a1 + a2; 

double distance = (hDif) / tan(aSum);

return distance;

}

void Vision::setCameraMode(int input)
{
    table->PutNumber("cameraMode", input);

/*
    Camera mode:
        0 = use the LED Mode set in the current pipeline
        1 = Driver Camera (Increase exposure, dsables vision procesesing)
*/
}

void Vision::setLedMode(int input)
{
    table->PutNumber("ledMode", input);

/*
    Led Mode:
    1 = force off
    2 = force blink
    3 force on
*/
}

void Vision::setPipeline(int input)
{
    table->PutNumber("pipeline", input);

/*  
sets the pipeline, (0-9)  
*/

}

void Vision::setStream(int input)
{
    table->PutNumber("stream", input);
}

